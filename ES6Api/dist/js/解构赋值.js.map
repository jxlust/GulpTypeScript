{"version":3,"sources":["解构赋值.js"],"names":["a","b","map","Map","set"],"mappings":"sBACc,CAAC,GAATA,UAAGC,UAmJTC,IAAA,IAAAC,IAKAD,IAAIE,IAAI,QAAS,SAHjBF,IAAAE,IAAA,SAAA","file":"解构赋值.js","sourcesContent":["// //1.解构不成功变量都是undefined\r\n let [a, b] = [1];\r\n// console.log(a);\r\n// console.log(b);\r\n// //2.解构数组需要对象是继承 Iterator 接口\r\n// let [x, y, z] = new Set(['a', 'b', 'c']);\r\n// //x // \"a\"\r\n// //3.默认值问题\r\n// function f() {\r\n//     console.log('aaa');\r\n// }\r\n// let [x2 = f()] = [1];\r\n// //上面代码中，因为x能取到值，所以函数f根本不会执行。\r\n// let [x3 = 1] = [undefined];\r\n// //x = 1;\r\n// let [y2 = 1] = [null];\r\n// //y = null \r\n// // null不严格等于undefined。\r\n// //默认值生效的条件是，对象的属性值严格等于undefined。\r\n\r\n// //3.对象的解构赋值\r\n// let {\r\n//     bar,\r\n//     foo\r\n// } = {\r\n//     foo: 'aaa',\r\n//     bar: 'bbb'\r\n// };\r\n// //foo // \"aaa\"\r\n// //bar // \"bbb\"\r\n\r\n// let {\r\n//     baz\r\n// } = {\r\n//     foo: 'aaa',\r\n//     bar: 'bbb'\r\n// };\r\n// //baz // undefined\r\n// let {\r\n//     foo: baz\r\n// } = {\r\n//     foo: 'aaa',\r\n//     bar: 'bbb'\r\n// };\r\n// let {\r\n//     x: y = 1\r\n// } = {} //y=1\r\n// let {\r\n//     x: y = 1\r\n// } = {\r\n//     x: 22\r\n// } //y = 22\r\n// //区分 匹配的模式的变量和真正的变量\r\n\r\n// //4. 声明的注意\r\n// // 因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\r\n// let x;\r\n// ({\r\n//     x\r\n// } = {\r\n//     x: 1\r\n// });\r\n// //5.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\r\n// let arr = [1, 2, 3];\r\n// let {\r\n//     0: first,\r\n//     [arr.length - 1]: last\r\n// } = arr;\r\n// // first  1\r\n// // last  3\r\n// //6.字符串\r\n// const [a, b, c, d, e] = 'hello';\r\n// // a  \"h\"\r\n// let {\r\n//     length: lt\r\n// } = 'hello';\r\n\r\n// //7.重点：函数参数的解构赋值\r\n// ['a', 'b'].map((value, index, arr) => {\r\n//     console.log('');\r\n//     return '_' + value;\r\n// });\r\n// //['a','b'].map((value) => ('_'+value))\r\n// //[['a','b'],['c','d']].map(([a,b]) => a + b)\r\n\r\n// function move({\r\n//     x = 0,\r\n//     y = 0\r\n// } = {}) {\r\n//     return [x, y];\r\n// }\r\n// //move({x = 1}) 等价于let x=1 {x=0,y=0} = {x}\r\n// function move({\r\n//     x,\r\n//     y\r\n// } = {\r\n//     x: 0,\r\n//     y: 0\r\n// }) {}\r\n// //move({}) 等价于 ({x,y} = {}) x y都是undefined \r\n\r\n// //8.重点解构赋值的用途\r\n// //8.1 交换变量的值\r\n// let a = 1;\r\n// let b = 2;\r\n// [b, a] = [a, b];\r\n// //({b:a,a:b} = {a,b});\r\n// //8.2 从函数返回多个值\r\n// //解构函数返回值\r\n// // 返回一个对象\r\n// function example() {\r\n//     return {\r\n//         foo: 1,\r\n//         bar: 2\r\n//     };\r\n// }\r\n// let {\r\n//     foo,\r\n//     bar\r\n// } = example();\r\n// //8.3 函数参数的定义\r\n// // 参数是一组有次序的值\r\n// function f([x, y, z]) {}\r\n// f([1, 2, 3]);\r\n\r\n// // 参数是一组无次序的值\r\n// function f({\r\n//     x,\r\n//     y,\r\n//     z\r\n// }) {}\r\n// f({\r\n//     z: 3,\r\n//     y: 2,\r\n//     x: 1\r\n// });\r\n// //8.4 提取json\r\n// let {\r\n//     a,\r\n//     b: number\r\n// } = {\r\n//     a: '粒子',\r\n//     b: [1, 2, 3]\r\n// }\r\n// //8.5 函数参数的赋值\r\n// var ajax = function (url, {\r\n//     a = 1,\r\n//     b = 2\r\n// } = {}){\r\n\r\n// }\r\n// //8.6 遍历 Map 结构\r\nconst map = new Map();\r\nmap.set('first', 'hello');\r\nmap.set('second', 'world');\r\n\r\n// for (let [key, value] of map) {\r\n//     console.log(key + \" is \" + value);\r\n// }\r\n// // 获取键名\r\n// for (let [key] of map) {\r\n//     // ...\r\n// }\r\n\r\n// // 获取键值\r\n// for (let [, value] of map) {\r\n//     // ...\r\n\r\n// }\r\n// //8.7 输入模块的指定方法\r\n// //import {a} from '';\r\n// //const {a,b} = require('');"]}